{% extends "layout.html" %}
{% block body %}

<!--
pre-determine all the locations
use this to determine location, height and width of rectangles
use this to determine location of arrows
draw rectangles + labels, then overlay copy of init g group, transition to new locations (delay)
draw rectangles + labels,then overlay copy of blocked group, transiion to treatment blocks
-->


<style type="text/css">
    .panel {
        width: 200px;
        border-color: #808080;
        padding: 10px 10px 10px 10px;
        margin-left: 30px;
    }
    .separator {
        margin-bottom: 10px;
        height: 1px;
        background-color: #808080;
    }
    svg .patient.red {
        fill: #F05133;
    }
    svg .patient.blue {
        fill: #569BBD;
    }
    svg .patient_number {
        font-size: 10px;
    }
</style>

<div class="row">
    <div class="col-md-7">
        <svg id="svg_canvas">
        </svg>
    </div>
    <div class="col-md-5">
        <div class="panel">
            <p> Example of blocking in a randomized experiment. </p>
            <div class="separator"></div>
            <p> <b>Step 1.</b> Divide patients into low-risk and high-risk blocks:
                <button id="button_create_blocks" type="button" class="btn btn-primary btn-xs"> Create Blocks </button>
            </p>
            <p> <b>Step 2.</b> Evenly separate each block of patients into the treatment groups using randomization:
                <button id="button_assign_groups" type="button" class="btn btn-primary btn-xs disabled"> Assign Groups </button>
            </p>
            <div class="separator"></div>
            <div>This strategy ensures an equal representation of patients in each treatment group from both the low-risk and high-risk categories, so patient risk does not bias the outcome of the experiment.
                <button id="button_reset" class="btn btn-primary btn-xs disabled"> Reset </button>
            </div>
        </div>
    </div>
</div>

<script type="text/javascript">
    // svg
    height = 1;
    width = height * 2;
    domain = [0, width];
    range = [0, 800];
    svg_scale = d3.scale.linear().domain(domain).range(range);
    var svg = d3.select("svg").attr("width", svg_scale(width)).attr("height", svg_scale(height));
    var svg_width = svg.attr("width");
    var svg_height = svg.attr("height");

    // colors
    blue = "#569BBD";
    green = "#4C721D";
    yellow = "#F4DC00";
    red = "#F05133";
    black = "#000000";
    gray = "#808080";
    lgray = "#D9D9D9";
    colors = [blue, red];
    color_names = ["blue","red"];

    // generate data
    datapoint_radius = svg_scale(0.0075);
    start_x = 0.05;
    start_y = 0.25;
    num_columns_in_block = 5
    spacing = 0.06;

    dataset = [];
    blues = [];
    reds = [];
    counter = 0;
    for(var y = 0; y < 9; y++){
        for(var x = 0; x < 6; x++){
            counter++;
            rand_index = Math.round(Math.random());
            datapoint = {
                "cx": svg_scale(start_x + x*spacing),
                "cy": svg_scale(start_y + y*spacing),
                "label": counter + "",
                "color": colors[rand_index],
                "class": "patient " + color_names[rand_index]
            };
            if(~datapoint["class"].indexOf("blue")){
                blues.push(datapoint);
            } else {
                reds.push(datapoint);
            }
        }
    }

    start_x = 0.65
    start_y = 0.15
    num_columns_in_block = 7
    for(var i = 0; i < blues.length; i++){
        blues[i]["cx_block"] = svg_scale(start_x + (i % num_columns_in_block)*spacing);
        blues[i]["cy_block"] = svg_scale(start_y + Math.ceil((i+1)/num_columns_in_block)*spacing);
    }

    start_y = start_y + 0.4;
    for(var i = 0; i < reds.length; i++){
        reds[i]["cx_block"] = svg_scale(start_x + (i % num_columns_in_block)*spacing);
        reds[i]["cy_block"] = svg_scale(start_y + Math.ceil((i+1)/num_columns_in_block)*spacing);
    }

    dataset = blues.concat(reds);

    var init = function(){
        var patients = svg.selectAll("g")
            .data(dataset)
            .enter()
            .append("g")
            .classed("patient_wrapper", true)
            .classed("blue",function(d){
                if(~d["class"].indexOf("blue")){
                    return true;
                }
                return false;
            })
            .classed("red",function(d){
                if(~d["class"].indexOf("red")){
                    return true;
                }
                return false;
            })

        patients.append("circle")
            .attr("cx", function(d, i) {
                return d["cx"];
            })
            .attr("cy", function(d, i) {
                return d["cy"];
            })
            .attr("r", datapoint_radius)
            .attr("class", function(d, i){
                return d["class"];
            });

        patients.append("text")
            .text(function(d){
                return d["label"];
            })
            .attr("x",function(d){
                return d["cx"];
            })
            .attr("y",function(d){
                return d["cy"] - 5;
            })
            .attr("font-family","sans-serif")
            .attr("text-anchor","middle")
            .attr("class", "patient_number");
    };

    function clone(selector) {
        var node = d3.select(selector).node();
        return d3.select(node.parentNode.insertBefore(node.cloneNode(true), node.nextSibling));
    }

    function cloneAll(selector) {
        var nodes = d3.selectAll(selector);
        nodes.each(function(d, i) {
            nodes[0][i] = this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
        });
        return nodes;
    }

    var create_blocks = function(){
        patient_blocks = cloneAll("g, .patient_wrapper")
            .classed("patient_wrapper", false)
            .classed("block_patient_wrapper", true)
            .data(dataset);

        patient_blocks.transition()
            .attr("transform",function(d){
                return "translate(" + (d["cx_block"] -  d["cx"]) + ", " + (d["cy_block"] - d["cy"]) + ")";
            });
    }

    var assign_groups = function(){

    };

    d3.select("#button_create_blocks").on("click", function(){
        create_blocks();
        d3.select("#button_create_blocks").classed("disabled", true)
        d3.select("#button_assign_groups").classed("disabled", false);
    });

    d3.select("#button_assign_groups").on("click", function(){
        assign_groups();
        d3.select("#button_assign_groups").classed("disabled", true)
        d3.select("#button_reset").classed("disabled", false);
    });

    d3.select("#button_reset").on("click", function(){
        init();
        d3.select("#button_reset").classed("disabled", true)
        d3.select("#button_create_blocks").classed("disabled", false);
    });

    init();

</script>

{% endblock %}
